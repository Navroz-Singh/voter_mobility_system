File: /src/actions/audit.js

"use server";

import { verifyLedgerIntegrity, verifyVoterChain, verifySingleEntry } from "@/lib/hashVerification";
import { revalidatePath } from "next/cache";

/**
 * Verifies the entire ledger chain integrity
 * @returns {Promise<{success: boolean, result?: object, error?: string}>}
 */
export async function verifyLedgerChainAction() {
  try {
    const result = await verifyLedgerIntegrity();
    revalidatePath("/admin/audit");
    return { success: true, result };
  } catch (error) {
    console.error("Ledger verification error:", error);
    return { success: false, error: "Verification failed" };
  }
}

/**
 * Verifies hash chain for a specific voter
 * @param {string} epicNumber - Voter's EPIC number
 * @returns {Promise<{success: boolean, result?: object, error?: string}>}
 */
export async function verifyVoterChainAction(epicNumber) {
  try {
    if (!epicNumber) {
      return { success: false, error: "EPIC number is required" };
    }

    const result = await verifyVoterChain(epicNumber);
    return { success: true, result };
  } catch (error) {
    console.error("Voter chain verification error:", error);
    return { success: false, error: "Verification failed" };
  }
}



/**
 * Verifies a single ledger entry
 * @param {string} entryId - Entry ID to verify
 * @returns {Promise<{success: boolean, result?: object, error?: string}>}
 */
export async function verifyEntryAction(entryId) {
  try {
    if (!entryId) {
      return { success: false, error: "Entry ID is required" };
    }

    const result = await verifySingleEntry(entryId);
    return { success: true, result };
  } catch (error) {
    console.error("Entry verification error:", error);
    return { success: false, error: "Verification failed" };
  }
}





















File: /src/actions/auth.js

"use server";
import { prisma } from "@/lib/db";
import { redirect } from "next/navigation";
import { cookies } from "next/headers";
import bcrypt from "bcrypt";
import { getOrCreateVoterKey } from "@/lib/encryption";

/**
 * Handles User Login (Voter, Officer, Admin)
 */
export async function loginAction(formData) {
  // 1. FORCE UPPERCASE to match the normalized storage format
  const identifier = formData.get("identifier")?.toUpperCase();
  const password = formData.get("password");

  if (!identifier || !password) {
    return { error: "Missing Credentials." };
  }

  // Find user by either EPIC (Voter) or Gov ID (Officer)
  const user = await prisma.user.findFirst({
    where: {
      OR: [{ epic_number: identifier }, { gov_id: identifier }],
    },
  });

  if (!user || !user.password_hash) {
    return { error: "Identity not recognized." };
  }

  // Prevent login if the account is still in "Placeholder" mode
  const isPlaceholder =
    user.password_hash === "OFFLINE_PROVISIONED_PENDING_CLAIM" ||
    user.password_hash === "OFFLINE_ENROLLMENT_PENDING_CLAIM";

  if (isPlaceholder) {
    return {
      error: "Account pending claim. Please use the 'Claim Account' button.",
    };
  }

  // Standard Password Verification
  const isValid = await bcrypt.compare(password, user.password_hash);
  if (!isValid) return { error: "Invalid Credentials." };

  // Create Session
  const cookieStore = await cookies();
  await cookieStore.set("vlink_session", user.id, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
    maxAge: 60 * 60 * 24, // 24 hours
    path: "/",
  });

  // Role-Based Redirects
  if (user.role === "ADMIN") redirect("/admin/audit");
  if (user.role === "OFFICER") redirect("/officer/register");
  if (user.role === "VOTER") redirect("/voter/authenticated/check");
}

/**
 * Handles "Claim Account" Logic (Formerly Register)
 */
export async function registerVoterAction(formData) {
  // 1. FORCE UPPERCASE to ensure we find the correct record
  const epic = formData.get("identifier")?.toUpperCase();
  const password = formData.get("password");

  if (!epic || !password) {
    return { error: "EPIC ID and New Password required." };
  }

  // Find the existing record created by the Officer
  const existingUser = await prisma.user.findUnique({
    where: { epic_number: epic },
  });

  if (!existingUser) {
    return {
      error: "No enrollment record found. Please visit a Field Officer.",
    };
  }

  // Security Check: Only allow claim if it's currently a placeholder
  const isPendingClaim =
    existingUser.password_hash === "OFFLINE_PROVISIONED_PENDING_CLAIM" ||
    existingUser.password_hash === "OFFLINE_ENROLLMENT_PENDING_CLAIM" || 
    existingUser.password_hash ==="PENDING_CLAIM";

  if (!isPendingClaim) {
    return { error: "Account already claimed. Please Sign In." };
  }

  // Hash the new password and update the user record
  const hashedPassword = await bcrypt.hash(password, 10);
  let userId = existingUser.id;

  try {
    await prisma.user.update({
      where: { epic_number: epic },
      data: {
        password_hash: hashedPassword, // Replace placeholder with real hash
        isVerified: true, // Mark account as verified by user
        status: "ACTIVE",
      },
    });

    // Create encryption key for the newly claimed user
    // This ensures data status checks work correctly
    try {
      await getOrCreateVoterKey(epic);
      console.log(`ðŸ” Encryption key created for newly claimed user: ${epic}`);
    } catch (keyError) {
      console.error("Failed to create encryption key during claim:", keyError);
      // Don't fail the entire claim process if key creation fails
      // The key will be created lazily on first data encryption
    }

    // Auto-Login the user immediately
    const cookieStore = await cookies();
    await cookieStore.set("vlink_session", userId, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      maxAge: 60 * 60 * 24,
      path: "/",
    });
  } catch (err) {
    console.error("Claim Error:", err);
    return { error: "System Error: Could not finalize claim." };
  }

  // Redirect to Voter Dashboard
  redirect("/voter/authenticated/check");
}

export async function logoutAction() {
  const cookieStore = await cookies();
  cookieStore.delete("vlink_session");
  redirect("/");
}





















File: /src/actions/conflicts.js

"use server";

import { prisma } from "@/lib/db";
import { sendToRelocationQueue } from "@/lib/rabbitmq"; // Your existing helper
import { revalidatePath } from "next/cache";

/**
 * Fetches conflicts from Postgres (populated by DLQ Worker)
 */
export async function getConflictsAction() {
  try {
    const conflicts = await prisma.conflictLog.findMany({
      where: { status: "PENDING" },
      orderBy: { createdAt: "desc" },
      take: 50,
    });

    return {
      success: true,
      conflicts: conflicts.map((c) => ({
        id: c.id, // DB ID
        epic: c.epic_number,
        // Helper to extract name safely from the JSON payload
        voter: `${c.original_payload?.payload?.firstName || ""} ${c.original_payload?.payload?.lastName || ""}`.trim(),
        issue: c.conflict_reason,
        timestamp: c.createdAt,
        version: c.actual_version || 0,
        // Pass full original data for retry logic
        fullEvent: c.original_payload 
      })),
    };
  } catch (error) {
    console.error("Error fetching conflicts:", error);
    return { success: false, error: "Database unavailable" };
  }
}

/**
 * Accept Remote: We effectively discard the failed packet because
 * we assume the system state is already fresher or we want to ignore the update.
 */
export async function acceptRemoteVersionAction(conflictId) {
  try {
    // Mark as resolved in DB so it disappears from UI
    await prisma.conflictLog.update({
      where: { id: conflictId },
      data: { status: "RESOLVED_DISCARDED" }
    });

    revalidatePath("/admin/conflicts");
    return { success: true, message: "Conflict resolved: Remote version accepted" };
  } catch (error) {
    console.error("Error resolving conflict:", error);
    return { success: false, error: "Failed to update conflict status" };
  }
}

/**
 * Keep Local (Force Retry): We take the original payload,
 * update its expected version to match the DB, and re-send to Main Queue.
 */
export async function keepLocalVersionAction(conflictId, eventData) {
  try {
    // 1. Get current live version from User table
    const currentUser = await prisma.user.findUnique({
      where: { epic_number: eventData.payload.epic.toUpperCase() },
      select: { version: true }
    });

    // 2. Patch the event with the *current* DB version
    // This allows the optimistic lock to pass when the worker processes it again
    const patchedEvent = {
      ...eventData,
      expected_version: currentUser ? currentUser.version : 0,
      retry_count: (eventData.retry_count || 0) + 1,
      retry_metadata: {
        retried_at: new Date().toISOString(),
        previous_conflict_id: conflictId
      }
    };

    // 3. Send back to MAIN Queue (Relocation Queue)
    await sendToRelocationQueue(patchedEvent);

    // 4. Mark conflict as resolved in DB
    await prisma.conflictLog.update({
      where: { id: conflictId },
      data: { status: "RESOLVED_RETRIED" }
    });

    revalidatePath("/admin/conflicts");
    return { success: true, message: "Conflict resolved: Re-queued for processing" };
  } catch (error) {
    console.error("Error resolving conflict:", error);
    return { success: false, error: "Failed to re-queue message" };
  }
}

/**
 * Retry a single processing error conflict
 */
export async function retryProcessingErrorAction(conflictId, eventData) {
  try {
    // Create a fresh event packet for retry
    const retryEvent = {
      ...eventData,
      retry_count: (eventData.retry_count || 0) + 1,
      retry_metadata: {
        retried_at: new Date().toISOString(),
        previous_conflict_id: conflictId,
        retry_reason: "manual_retry"
      }
    };

    // Send back to MAIN Queue
    await sendToRelocationQueue(retryEvent);

    // Mark conflict as resolved
    await prisma.conflictLog.update({
      where: { id: conflictId },
      data: { status: "RESOLVED_RETRIED" }
    });

    revalidatePath("/admin/conflicts");
    return { success: true, message: "Processing error retried successfully" };
  } catch (error) {
    console.error("Error retrying processing error:", error);
    return { success: false, error: "Failed to retry processing error" };
  }
}

/**
 * Retry all processing error conflicts
 */
export async function retryAllProcessingErrorsAction() {
  try {
    // Get all processing error conflicts
    const processingErrors = await prisma.conflictLog.findMany({
      where: {
        status: "PENDING",
        conflict_reason: "PROCESSING_ERROR"
      },
      orderBy: { createdAt: "desc" }
    });

    let successCount = 0;
    let failCount = 0;

    // Retry each one
    for (const conflict of processingErrors) {
      try {
        const retryEvent = {
          ...conflict.original_payload,
          retry_count: (conflict.original_payload.retry_count || 0) + 1,
          retry_metadata: {
            retried_at: new Date().toISOString(),
            previous_conflict_id: conflict.id,
            retry_reason: "bulk_retry"
          }
        };

        await sendToRelocationQueue(retryEvent);

        // Mark as resolved
        await prisma.conflictLog.update({
          where: { id: conflict.id },
          data: { status: "RESOLVED_RETRIED" }
        });

        successCount++;
      } catch (error) {
        console.error(`Failed to retry conflict ${conflict.id}:`, error);
        failCount++;
      }
    }

    revalidatePath("/admin/conflicts");
    return {
      success: true,
      message: `Retried ${successCount} conflicts, ${failCount} failed`,
      successCount,
      failCount
    };
  } catch (error) {
    console.error("Error in bulk retry:", error);
    return { success: false, error: "Failed to retry all processing errors" };
  }
}





















File: /src/actions/officer.js

"use server";
import { prisma } from "@/lib/db";
import { sendToRelocationQueue } from "@/lib/rabbitmq";
import { revalidatePath } from "next/cache";

// --- 1. EXISTING: Fetch Logic ---
export async function fetchVoterByEPIC(epicNumber) {
  if (!epicNumber || typeof epicNumber !== "string") {
    return { error: "Invalid EPIC number" };
  }
  const normalized = epicNumber.toUpperCase().trim();
  try {
    const voter = await prisma.user.findUnique({
      where: { epic_number: normalized },
      include: {
        relocationRequests: {
          where: { status: "PENDING" },
          orderBy: { createdAt: "desc" },
          take: 1,
        },
      },
    });
    if (!voter) return { error: "No voter found with this EPIC ID." };
    return { success: true, voter };
  } catch (error) {
    console.error("Fetch Error:", error);
    return { error: "Database connection failed." };
  }
}

// --- 2. NEW: Batch Sync Logic (For Sync & Logout) ---
/**
 * Submits a batch of events from PouchDB to the queue
 * @param {Array} events - Array of PouchDB documents with voter data
 */
export async function submitEventBatch(events) {
  if (!Array.isArray(events) || events.length === 0) {
    return { success: true, synced: 0, failed: 0 };
  }

  let synced = 0;
  let failed = 0;
  const errors = [];

  for (const event of events) {
    try {
      // Normalize data structure
      const epic = (event.epic || event.epic_number || "").toUpperCase().trim();
      const aadhaar = (event.aadhaar || event.aadhaar_uid || "").trim();

      // Basic Validation
      if (!epic) {
        errors.push({ id: event._id, error: "Missing EPIC number" });
        failed++;
        continue;
      }

      // Check if voter exists to get version for CAS (Concurrency Control)
      let expectedVersion = undefined;
      let existingVoterId = null;
      let isNewEnrollment = false;

      try {
        const existingVoter = await prisma.user.findUnique({
          where: { epic_number: epic },
          select: { id: true, version: true },
        });
        if (existingVoter) {
          expectedVersion = existingVoter.version;
          existingVoterId = existingVoter.id;
        }
      } catch (dbError) {
        // If DB fails, we log but continue processing other records
        console.warn(
          `Version check failed for ${epic}, treating as new/blind write.`
        );
      }

      // For new enrollments, create user directly in DB for immediate availability
      if (!existingVoterId) {
        try {
          const newVoter = await prisma.user.create({
            data: {
              epic_number: epic,
              firstName: event.firstName || "",
              lastName: event.lastName || "",
              aadhaar_uid: aadhaar,
              constituency: event.constituency || "",
              password_hash: "PENDING_CLAIM",
              version: 1,
              status: "ACTIVE",
              role: "VOTER",
            },
          });
          existingVoterId = newVoter.id;
          expectedVersion = 1;
          isNewEnrollment = true;
          console.log(`âœ… User created directly in DB from batch sync: ${epic}`);
        } catch (createError) {
          // If creation fails (e.g., duplicate), log and continue to queue
          console.warn(`User creation failed for ${epic}:`, createError.message);
        }
      }

      // Prepare event packet
      const eventPacket = {
        type: isNewEnrollment ? "OFFLINE_ENROLLMENT_COMMIT" : "IDENTITY_MIGRATION_COMMIT",
        version: 2.1,
        requestId: null, // Batch events usually don't have a pre-existing RelocationRequest ID
        voterId: existingVoterId,
        expected_version: expectedVersion,
        payload: {
          firstName: event.firstName || "",
          lastName: event.lastName || "",
          epic: epic,
          aadhaar: aadhaar,
          constituency: event.constituency || "",
        },
        metadata: {
          fieldUnit: "402",
          timestamp: event.timestamp || new Date().toISOString(),
          source: "POUCHDB_BATCH_SYNC",
          original_id: event._id,
        },
      };

      // Send to queue
      const brokerResponse = await sendToRelocationQueue(eventPacket);

      if (brokerResponse.success) {
        synced++;
      } else {
        errors.push({
          id: event._id,
          error: brokerResponse.error || "Queue rejected packet",
        });
        failed++;
      }
    } catch (error) {
      console.error("Batch Item Error:", error);
      errors.push({
        id: event._id,
        error: error.message || "Processing error",
      });
      failed++;
    }
  }

  // Refresh Queue UI if officer is looking at it
  revalidatePath("/officer/queue");

  return {
    success: failed === 0,
    synced,
    failed,
    errors: errors.length > 0 ? errors : undefined,
  };
}

// --- 3. EXISTING: Single Commit Logic ---
export async function commitVoterUpdate(voterId, updateData) {
  try {
    let pendingReqId = null;
    let expectedVersion = undefined;
    let isNewEnrollment = false;

    // NEW: For new enrollments (no voterId), create user record directly in DB first
    // This ensures the voter can claim their account immediately after officer registration
    if (!voterId && updateData.epic) {
      const normalizedEpic = updateData.epic.toUpperCase().trim();
      
      // Check if voter already exists
      const existingVoter = await prisma.user.findUnique({
        where: { epic_number: normalizedEpic },
      });

      if (existingVoter) {
        return { error: "Voter with this EPIC number already exists." };
      }

      // Create user record directly for immediate availability
      try {
        const newVoter = await prisma.user.create({
          data: {
            epic_number: normalizedEpic,
            firstName: updateData.firstName || "",
            lastName: updateData.lastName || "",
            aadhaar_uid: updateData.aadhaar || "",
            constituency: updateData.constituency || "",
            password_hash: "PENDING_CLAIM",
            version: 1,
            status: "ACTIVE",
            role: "VOTER",
          },
        });
        voterId = newVoter.id;
        expectedVersion = 1;
        isNewEnrollment = true;
        console.log(`âœ… User created directly in DB: ${normalizedEpic}`);
      } catch (createError) {
        console.error("Direct DB Create Error:", createError);
        return { error: "Failed to create voter record." };
      }
    }

    // 1. Branch Logic: If voterId exists AND it's NOT a fresh enrollment, this is a Relocation/Update
    if (voterId && !isNewEnrollment) {
      // Fetch current user to get version for CAS
      const currentVoter = await prisma.user.findUnique({
        where: { id: voterId },
        select: {
          id: true,
          version: true,
          epic_number: true,
          aadhaar_uid: true,
          firstName: true,
          lastName: true,
        },
      });

      if (!currentVoter) {
        return { error: "Voter not found" };
      }

      // Get current version for optimistic concurrency control
      expectedVersion = currentVoter.version;

      const pendingReq = await prisma.relocationRequest.findFirst({
        where: { voterId, status: "PENDING" },
      });

      if (pendingReq) pendingReqId = pendingReq.id;

      // Fill in missing identifiers from current voter
      if (!updateData.epic || !updateData.aadhaar) {
        updateData.epic = updateData.epic || currentVoter.epic_number;
        updateData.aadhaar = updateData.aadhaar || currentVoter.aadhaar_uid;
        updateData.firstName = updateData.firstName || currentVoter.firstName;
        updateData.lastName = updateData.lastName || currentVoter.lastName;
      }
    }

    // 2. Prepare the Event Packet
    // Use OFFLINE_ENROLLMENT_COMMIT for new enrollments, IDENTITY_MIGRATION_COMMIT for updates
    const eventPacket = {
      type: isNewEnrollment ? "OFFLINE_ENROLLMENT_COMMIT" : "IDENTITY_MIGRATION_COMMIT",
      version: 2.1,
      requestId: pendingReqId,
      voterId: voterId,
      expected_version: expectedVersion,
      payload: {
        firstName: updateData.firstName,
        lastName: updateData.lastName,

        // Now this will always be populated, even for updates
        epic: updateData.epic,
        aadhaar: updateData.aadhaar,

        constituency: updateData.constituency,
      },
      metadata: {
        fieldUnit: "402",
        timestamp: new Date().toISOString(),
      },
    };

    // 3. Dispatch to RabbitMQ
    console.log(
      "ðŸ“¦ [3] Dispatching Complete Packet:",
      JSON.stringify(eventPacket, null, 2)
    );

    const brokerResponse = await sendToRelocationQueue(eventPacket);
    if (!brokerResponse.success) {
      return { error: "Sync Error: RabbitMQ Broker unreachable." };
    }

    // 4. Update status ONLY if it was a relocation
    if (voterId && pendingReqId) {
      await prisma.relocationRequest.update({
        where: { id: pendingReqId },
        data: { status: "PROCESSING" },
      });
    }

    revalidatePath("/officer/update");
    revalidatePath("/officer/queue");
    return { success: true };
  } catch (error) {
    console.error("PIPELINE ERROR:", error);
    return { error: "Critical failure in commit pipeline." };
  }
}





















File: /src/actions/privacy.js

"use server";

import { prisma } from "@/lib/db";
import { deleteVoterKey, canDecryptVoterData, decryptPayload, encryptPayload } from "@/lib/encryption";
import { revalidatePath } from "next/cache";
import crypto from "crypto";

/**
 * Shreds a voter's personal data by deleting their encryption key
 * @param {string} voterId - EPIC number or voter ID
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function shredVoterDataAction(voterId) {
  try {
    if (!voterId) {
      return { success: false, error: "Voter ID is required" };
    }

    // Normalize EPIC to uppercase
    const normalizedVoterId = voterId.toUpperCase();

    // Check if key exists
    const keyExists = await canDecryptVoterData(normalizedVoterId);
    if (!keyExists) {
      return { 
        success: false, 
        error: "Voter data already shredded or key not found" 
      };
    }

    // Get user record to log the shredding event
    const user = await prisma.user.findUnique({
      where: { epic_number: normalizedVoterId },
      include: { auditLogs: { orderBy: { timestamp: "desc" }, take: 1 } },
    });

    if (!user) {
      return { success: false, error: "Voter not found" };
    }

    // 1. Encrypt the shred payload BEFORE starting transaction (avoid nested DB calls)
    const prevHash = user.auditLogs[0]?.curr_hash || "0";

    const shredPayload = {
      action: "SHRED_REQUEST",
      voterId: normalizedVoterId,
      timestamp: new Date().toISOString()
    };
    const { encrypted, iv } = await encryptPayload(normalizedVoterId, shredPayload);

    const currHash = crypto
      .createHash("sha256")
      .update(prevHash + encrypted + iv + "ADMIN_SHRED_SIG")
      .digest("hex");

    // 2. Perform shredding in transaction (only DB writes)
    await prisma.$transaction(async (tx) => {
      // Log the shredding event to ledger
      await tx.auditLog.create({
        data: {
          userId: user.id,
          eventType: "SHRED_REQUEST",
          encrypted_payload: encrypted,
          iv: iv,
          signature: "ADMIN_SHRED_SIG",
          prev_hash: prevHash,
          curr_hash: currHash,
        },
      });

      // Update user status to DELETED
      await tx.user.update({
        where: { id: user.id },
        data: { status: "DELETED" },
      });
    });

    // 3. Delete the encryption key AFTER transaction (this makes data unreadable)
    await deleteVoterKey(normalizedVoterId);

    revalidatePath("/admin/privacy");
    return { success: true, message: "Voter data successfully shredded" };
  } catch (error) {
    console.error("Shredding error:", error);
    return { success: false, error: "Failed to shred voter data" };
  }
}

/**
 * Checks if a voter's data can be decrypted
 * @param {string} voterId - EPIC number
 * @returns {Promise<{canDecrypt: boolean, error?: string}>}
 */
export async function checkVoterDataStatusAction(voterId) {
  try {
    if (!voterId) {
      return { canDecrypt: false, error: "Voter ID is required" };
    }

    const normalizedVoterId = voterId.toUpperCase();

    // First check if encryption key exists
    const canDecrypt = await canDecryptVoterData(normalizedVoterId);

    if (canDecrypt) {
      return {
        canDecrypt: true,
        message: "Data is readable"
      };
    }

    // If no key exists, check if this is a newly claimed user
    // (user exists with a real password but no encrypted data yet)
    const user = await prisma.user.findUnique({
      where: { epic_number: normalizedVoterId },
      select: {
        password_hash: true,
        status: true,
        auditLogs: {
          select: { id: true },
          take: 1
        }
      }
    });

    if (user) {
      // If user exists and has a real password (not placeholder)
      const hasRealPassword = user.password_hash &&
                             user.password_hash !== "PENDING_CLAIM" &&
                             user.password_hash !== "OFFLINE_PROVISIONED_PENDING_CLAIM" &&
                             user.password_hash !== "OFFLINE_ENROLLMENT_PENDING_CLAIM";

      // If user has audit logs but no key, data was shredded
      if (hasRealPassword) {
        return {
          canDecrypt: false,
          message: "Data has been shredded (key deleted)"
        };
      }


      // If user has placeholder password, they're not claimed yet
      if (!hasRealPassword) {
        return {
          canDecrypt: false,
          error: "Account not claimed yet"
        };
      }
    }

    // User doesn't exist or other edge case
    return {
      canDecrypt: false,
      error: "Voter not found"
    };
  } catch (error) {
    console.error("Status check error:", error);
    return { canDecrypt: false, error: "Failed to check status" };
  }
}


/**
 * Attempts to decrypt and return voter data (for testing/verification)
 * @param {string} voterId - EPIC number
 * @returns {Promise<{success: boolean, data?: object, error?: string}>}
 */
export async function decryptVoterDataAction(voterId) {
  try {
    if (!voterId) {
      return { success: false, error: "Voter ID is required" };
    }

    const normalizedVoterId = voterId.toUpperCase();

    // Get the latest ledger entry
    const user = await prisma.user.findUnique({
      where: { epic_number: normalizedVoterId },
      include: { 
        auditLogs: { 
          orderBy: { timestamp: "desc" }, 
          take: 1 
        } 
      },
    });

    if (!user || !user.auditLogs[0]) {
      return { success: false, error: "No ledger entry found" };
    }

    const latestLog = user.auditLogs[0];

    // Attempt to decrypt
    try {
      const decrypted = await decryptPayload(
        normalizedVoterId,
        latestLog.encrypted_payload,
        latestLog.iv
      );

      return { success: true, data: decrypted };
    } catch (decryptError) {
      if (decryptError.message.includes("not found") || decryptError.message.includes("shredded")) {
        return { 
          success: false, 
          error: "Data has been cryptographically shredded. Key not found." 
        };
      }
      throw decryptError;
    }
  } catch (error) {
    console.error("Decryption error:", error);
    return { success: false, error: "Failed to decrypt data" };
  }
}





















File: /src/actions/relocation.js

"use server";

import { prisma } from "@/lib/db";
import { cookies } from "next/headers";
import { revalidatePath } from "next/cache";
import crypto from "crypto";
import { encryptPayload } from "@/lib/encryption";

export async function requestRelocationAction(formData) {
  const targetZone = formData.get("targetZone");
  const cookieStore = await cookies();
  const sessionId = cookieStore.get("vlink_session")?.value;

  if (!sessionId || !targetZone)
    return { error: "Session or Target Zone missing." };

  try {
    // --- FIX: Added options object as the second argument ---
    return await prisma.$transaction(
      async (tx) => {
        // 1. Get current user snapshot
        const user = await tx.user.findUnique({ where: { id: sessionId } });

        if (!user) {
          return { error: "User not found" };
        }

        // 2. Create the PENDING Request (Buffer Layer)
        await tx.relocationRequest.create({
          data: {
            voterId: user.id,
            fromZone: user.constituency || "UNASSIGNED",
            toZone: targetZone,
            status: "PENDING",
          },
        });

        // 3. Hash-Link to the Immutable Ledger
        const lastLog = await tx.auditLog.findFirst({
          where: { userId: user.id },
          orderBy: { timestamp: "desc" },
        });

        const prevHash = lastLog?.curr_hash || "0";
        const payloadData = { from: user.constituency, to: targetZone };

        if (!user.epic_number) {
          throw new Error("User EPIC number is required for encryption");
        }

        const { encrypted, iv } = await encryptPayload(
          user.epic_number,
          payloadData
        );

        const currHash = crypto
          .createHash("sha256")
          .update(prevHash + encrypted + iv + "VOTER_AUTH_SIG")
          .digest("hex");

        await tx.auditLog.create({
          data: {
            userId: user.id,
            eventType: "RELOCATION_INITIATED",
            encrypted_payload: encrypted,
            iv: iv,
            signature: "VOTER_AUTH_SIG",
            prev_hash: prevHash,
            curr_hash: currHash,
          },
        });

        revalidatePath("/voter/relocate");
        return { success: true };
      },
      {
        // --- TIMEOUT SETTINGS ---
        maxWait: 5000, // Max time to wait for a database connection
        timeout: 20000, // Max time the transaction can run (20s) before Prisma cancels it
      }
    );
  } catch (err) {
    console.error("Transaction Failed:", err);
    return { error: "Database transaction failed (Latency/Timeout)." };
  }
}





















File: /src/actions/sync.js

"use server";
import { prisma } from "@/lib/db";
import { sendToRelocationQueue } from "@/lib/rabbitmq";
import { revalidatePath } from "next/cache";

/**
 * Submits a batch of events from PouchDB to the queue
 * @param {Array} events - Array of PouchDB documents with voter data
 * @returns {Promise<{success: boolean, synced: number, failed: number, errors?: Array}>}
 */
export async function submitEventBatch(events) {
  if (!Array.isArray(events) || events.length === 0) {
    return { success: true, synced: 0, failed: 0 };
  }

  let synced = 0;
  let failed = 0;
  const errors = [];

  for (const event of events) {
    try {
      // Validate event structure
      if (!event.epic && !event.epic_number) {
        errors.push({
          id: event._id,
          error: "Missing EPIC number",
        });
        failed++;
        continue;
      }

      // Normalize data structure
      const epic = (event.epic || event.epic_number || "").toUpperCase();
      const aadhaar = event.aadhaar || event.aadhaar_uid || "";

      if (!epic) {
        errors.push({
          id: event._id,
          error: "EPIC number is required",
        });
        failed++;
        continue;
      }

      // Check if voter exists to get version for CAS
      let expectedVersion = undefined;
      let existingVoterId = null;
      let isNewEnrollment = false;

      try {
        const existingVoter = await prisma.user.findUnique({
          where: { epic_number: epic },
          select: { id: true, version: true },
        });
        if (existingVoter) {
          expectedVersion = existingVoter.version;
          existingVoterId = existingVoter.id;
        }
      } catch (dbError) {
        // If voter doesn't exist, expectedVersion stays undefined (new registration)
        console.log("New voter registration:", epic);
      }

      // For new enrollments, create user directly in DB for immediate availability
      if (!existingVoterId) {
        try {
          const newVoter = await prisma.user.create({
            data: {
              epic_number: epic,
              firstName: event.firstName || "",
              lastName: event.lastName || "",
              aadhaar_uid: aadhaar,
              constituency: event.constituency || "",
              password_hash: "PENDING_CLAIM",
              version: 1,
              status: "ACTIVE",
              role: "VOTER",
            },
          });
          existingVoterId = newVoter.id;
          expectedVersion = 1;
          isNewEnrollment = true;
          console.log(`âœ… User created directly in DB from PouchDB sync: ${epic}`);
        } catch (createError) {
          // If creation fails (e.g., duplicate), log and continue to queue
          console.warn(`User creation failed for ${epic}:`, createError.message);
        }
      }

      // Prepare event packet
      const eventPacket = {
        type: isNewEnrollment ? "OFFLINE_ENROLLMENT_COMMIT" : "IDENTITY_MIGRATION_COMMIT",
        version: 2.1,
        requestId: null,
        voterId: existingVoterId,
        expected_version: expectedVersion,
        payload: {
          firstName: event.firstName || "",
          lastName: event.lastName || "",
          epic: epic,
          aadhaar: aadhaar,
          constituency: event.constituency || "",
        },
        metadata: {
          fieldUnit: "402",
          timestamp: event.timestamp || new Date().toISOString(),
          source: "POUCHDB_SYNC",
          original_id: event._id,
        },
      };

      // Send to queue
      const brokerResponse = await sendToRelocationQueue(eventPacket);
      if (brokerResponse.success) {
        synced++;
      } else {
        errors.push({
          id: event._id,
          error: brokerResponse.error || "Queue error",
        });
        failed++;
      }
    } catch (error) {
      console.error("Error processing event:", error);
      errors.push({
        id: event._id,
        error: error.message || "Processing error",
      });
      failed++;
    }
  }

  revalidatePath("/officer/queue");
  
  return {
    success: failed === 0,
    synced,
    failed,
    errors: errors.length > 0 ? errors : undefined,
  };
}

// Keep the old function for backward compatibility
export async function commitVoterUpdate(voterId, updateData) {
  try {
    let pendingReqId = null;
    let expectedVersion = undefined;

    if (voterId) {
      const currentVoter = await prisma.user.findUnique({
        where: { id: voterId },
        select: { version: true, epic_number: true, aadhaar_uid: true },
      });

      if (currentVoter) {
        expectedVersion = currentVoter.version;
        updateData.epic = updateData.epic || currentVoter.epic_number;
        updateData.aadhaar = updateData.aadhaar || currentVoter.aadhaar_uid;
      }

      const pendingReq = await prisma.relocationRequest.findFirst({
        where: { voterId, status: "PENDING" },
      });

      if (pendingReq) pendingReqId = pendingReq.id;
    }

    const eventPacket = {
      type: voterId ? "IDENTITY_MIGRATION_COMMIT" : "OFFLINE_ENROLLMENT_COMMIT",
      version: 2.1,
      requestId: pendingReqId,
      voterId: voterId,
      expected_version: expectedVersion, // âœ… Include for CAS
      payload: {
        firstName: updateData.firstName,
        lastName: updateData.lastName,
        epic: updateData.epic,
        aadhaar: updateData.aadhaar,
        constituency: updateData.constituency,
      },
      metadata: {
        fieldUnit: "402",
        timestamp: new Date().toISOString(),
      },
    };

    const brokerResponse = await sendToRelocationQueue(eventPacket);
    if (!brokerResponse.success) {
      return { error: "Sync Error: RabbitMQ Broker unreachable." };
    }

    if (voterId && pendingReqId) {
      await prisma.relocationRequest.update({
        where: { id: pendingReqId },
        data: { status: "PROCESSING" },
      });
    }

    revalidatePath("/officer/update");
    revalidatePath("/officer/queue");
    return { success: true };
  } catch (error) {
    console.error("PIPELINE ERROR:", error);
    return { error: "Critical failure in commit pipeline." };
  }
}





















File: /src/actions/worker.js

"use server";
import { spawn } from "child_process";
import { revalidatePath } from "next/cache";

let workerProcess = null;

export async function startLedgerWorkerAction() {
  console.log("ðŸš€ [System] Request received to start Ledger Worker...");

  // 1. Force Kill existing worker if running (Hard Reset)
  if (workerProcess) {
    console.log("ðŸ”„ [System] Stopping active worker to restart...");
    workerProcess.kill();
    workerProcess = null;
    // Brief pause to ensure the port/file handles release
    await new Promise((resolve) => setTimeout(resolve, 500));
  }

  try {
    // 2. Spawn new worker with "inherit" to pipe logs to VS Code Terminal
    workerProcess = spawn("node", ["src/workers/ledgerWorker.js"], {
      stdio: "inherit",
    });

    workerProcess.on("error", (err) => {
      console.error("âŒ [Worker Error]:", err);
      workerProcess = null;
    });

    workerProcess.on("close", (code) => {
      // Don't log if we killed it intentionally (null check)
      if (workerProcess) {
        console.log(`[System] Worker stopped with code ${code}`);
        workerProcess = null;
      }
    });

    // 3. Wait a moment for startup logs to print
    await new Promise((resolve) => setTimeout(resolve, 1000));

    revalidatePath("/officer/queue");
    return { success: true };
  } catch (error) {
    console.error("Failed to spawn worker:", error);
    return { success: false, error: "Worker failed to start" };
  }
}





















File: /src/app/api/admin/ledger/route.js

import { prisma } from "@/lib/db";
import { verifyLedgerIntegrity } from "@/lib/hashVerification";
import { NextResponse } from "next/server";

export async function GET() {
  try {
    // Fetch all ledger entries
    const entries = await prisma.auditLog.findMany({
      orderBy: { timestamp: "desc" },
      select: {
        id: true,
        eventType: true,
        curr_hash: true,
        prev_hash: true,
        timestamp: true,
        signature: true,
      },
      take: 1000, // Limit to last 1000 entries for performance
    });

    // Get integrity status
    const integrityResult = await verifyLedgerIntegrity();
    const integrity = integrityResult.valid
      ? `${integrityResult.verifiedCount}/${integrityResult.totalEntries} Verified`
      : `${integrityResult.errors.length} Errors`;

    return NextResponse.json({
      entries: entries.map((entry) => ({
        id: entry.id,
        eventType: entry.eventType,
        curr_hash: entry.curr_hash,
        prev_hash: entry.prev_hash,
        timestamp: entry.timestamp,
        signature: entry.signature,
      })),
      integrity,
      totalEntries: entries.length,
    });
  } catch (error) {
    console.error("Error fetching ledger:", error);
    return NextResponse.json(
      { error: "Failed to fetch ledger data", entries: [], integrity: "Error" },
      { status: 500 }
    );
  }
}





















File: /src/app/api/auth/[...nextauth]/route.js























File: /src/app/api/ping/route.js

/**
 * Ultra-lightweight latency measurement endpoint
 * No database access, no middleware, responds in <5ms
 */

export async function GET() {
  return Response.json({
    ok: true,
    timestamp: Date.now(),
  });
}

// Also support HEAD requests for even lighter pings
export async function HEAD() {
  return new Response(null, { status: 200 });
}





















File: /src/hooks/useNetworkStatus.js

"use client";
import { useState, useEffect, useRef, useCallback } from "react";

// Thresholds for connection quality
const GOOD_LATENCY_THRESHOLD = 300; // ms - connection considered good
const POOR_LATENCY_THRESHOLD = 1000; // ms - connection considered poor
const PING_INTERVAL = 5000; // 5 seconds between pings
const PING_TIMEOUT = 2000; // 2 second timeout for each ping
const MOVING_AVERAGE_SIZE = 3; // Number of pings to average

/**
 * Latency-based network quality detection hook
 * Replaces simple online/offline with actual connection quality measurement
 * 
 * @returns {{
 *   latency: number | null,
 *   isGoodConnection: boolean,
 *   isPoorConnection: boolean,
 *   lastCheckedAt: Date | null,
 *   isOnline: boolean // Backward compatibility
 * }}
 */
export function useNetworkStatus() {
  const [state, setState] = useState({
    latency: null,
    isGoodConnection: true, // Optimistic default
    isPoorConnection: false,
    lastCheckedAt: null,
  });

  const latencyHistoryRef = useRef([]);
  const abortControllerRef = useRef(null);
  const intervalRef = useRef(null);

  /**
   * Calculate moving average of latency values
   */
  const calculateMovingAverage = useCallback((history) => {
    if (history.length === 0) return null;
    const sum = history.reduce((acc, val) => acc + val, 0);
    return Math.round(sum / history.length);
  }, []);

  /**
   * Perform a single ping and measure latency
   */
  const measureLatency = useCallback(async () => {
    // Abort any pending request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();
    const startTime = performance.now();

    try {
      const response = await fetch("/api/ping", {
        method: "GET",
        cache: "no-store",
        signal: abortControllerRef.current.signal,
        // Set timeout via AbortController
        ...(typeof AbortSignal.timeout === "function" && {
          signal: AbortSignal.timeout(PING_TIMEOUT),
        }),
      });

      if (!response.ok) {
        throw new Error(`Ping failed: ${response.status}`);
      }

      const endTime = performance.now();
      const latency = Math.round(endTime - startTime);

      // Update history with moving average window
      const newHistory = [...latencyHistoryRef.current, latency].slice(
        -MOVING_AVERAGE_SIZE
      );
      latencyHistoryRef.current = newHistory;

      const avgLatency = calculateMovingAverage(newHistory);
      const isGoodConnection = avgLatency !== null && avgLatency <= GOOD_LATENCY_THRESHOLD;
      const isPoorConnection = avgLatency !== null && avgLatency >= POOR_LATENCY_THRESHOLD;

      setState({
        latency: avgLatency,
        isGoodConnection,
        isPoorConnection,
        lastCheckedAt: new Date(),
      });

      return { latency: avgLatency, isGoodConnection, isPoorConnection };
    } catch (error) {
      // Handle timeout or network errors
      if (error.name === "AbortError" || error.name === "TimeoutError") {
        // Timeout - treat as very poor connection
        const newHistory = [...latencyHistoryRef.current, PING_TIMEOUT].slice(
          -MOVING_AVERAGE_SIZE
        );
        latencyHistoryRef.current = newHistory;

        const avgLatency = calculateMovingAverage(newHistory);

        setState({
          latency: avgLatency,
          isGoodConnection: false,
          isPoorConnection: true,
          lastCheckedAt: new Date(),
        });

        return { latency: avgLatency, isGoodConnection: false, isPoorConnection: true };
      }

      // Network completely unavailable
      setState((prev) => ({
        ...prev,
        isGoodConnection: false,
        isPoorConnection: true,
        lastCheckedAt: new Date(),
      }));

      return { latency: null, isGoodConnection: false, isPoorConnection: true };
    }
  }, [calculateMovingAverage]);

  /**
   * Start periodic latency measurement
   */
  useEffect(() => {
    if (typeof window === "undefined") return;

    // Initial ping
    measureLatency();

    // Set up periodic pings
    intervalRef.current = setInterval(() => {
      measureLatency();
    }, PING_INTERVAL);

    // Cleanup
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [measureLatency]);

  // Return state with backward compatibility (isOnline maps to isGoodConnection)
  return {
    ...state,
    isOnline: state.isGoodConnection, // Backward compatibility
  };
}

/**
 * Export thresholds for external use (e.g., SyncManager)
 */
export const LATENCY_THRESHOLDS = {
  GOOD: GOOD_LATENCY_THRESHOLD,
  POOR: POOR_LATENCY_THRESHOLD,
};





















File: /src/lib/db.js

import { PrismaClient } from "@prisma/client";

const globalForPrisma = global;

export const prisma = globalForPrisma.prisma || new PrismaClient();

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;





















File: /src/lib/encryption.js

import crypto from "crypto";
// âœ… Correct (Add curly braces)
import { prisma } from "./db.js";

// Master Key for encrypting voter keys (In production, use HSM or AWS KMS)
// Store this in environment variable: MASTER_ENCRYPTION_KEY
const MASTER_KEY =
  process.env.MASTER_ENCRYPTION_KEY || crypto.randomBytes(32).toString("hex");
const MASTER_IV =
  process.env.MASTER_IV || crypto.randomBytes(16).toString("hex");

/**
 * Generates a new AES-256 key for a voter
 * @param {string} voterId - The voter's EPIC number or unique ID
 * @returns {Buffer} - Raw AES-256 key (32 bytes)
 */
export function generateVoterKey(voterId) {
  // Generate a unique key for this voter
  const keyMaterial = crypto
    .createHash("sha256")
    .update(voterId + Date.now() + crypto.randomBytes(16).toString("hex"))
    .digest();

  return keyMaterial; // 32 bytes for AES-256
}

/**
 * Encrypts the voter's key using the master key
 * @param {Buffer} voterKey - Raw voter key
 * @returns {string} - Encrypted key (hex string)
 */
function encryptVoterKeyWithMaster(voterKey) {
  const cipher = crypto.createCipheriv(
    "aes-256-gcm",
    Buffer.from(MASTER_KEY, "hex"),
    Buffer.from(MASTER_IV, "hex")
  );

  let encrypted = cipher.update(voterKey, null, "hex");
  encrypted += cipher.final("hex");

  const authTag = cipher.getAuthTag().toString("hex");

  // Store IV and authTag with encrypted key
  return `${encrypted}:${MASTER_IV}:${authTag}`;
}

/**
 * Decrypts the voter's key using the master key
 * @param {string} encryptedKeyString - Encrypted key string
 * @returns {Buffer} - Decrypted voter key
 */
function decryptVoterKeyWithMaster(encryptedKeyString) {
  const [encrypted, iv, authTag] = encryptedKeyString.split(":");

  const decipher = crypto.createDecipheriv(
    "aes-256-gcm",
    Buffer.from(MASTER_KEY, "hex"),
    Buffer.from(iv, "hex")
  );
  decipher.setAuthTag(Buffer.from(authTag, "hex"));

  let decrypted = decipher.update(encrypted, "hex", null);
  decrypted = Buffer.concat([decrypted, decipher.final()]);

  return decrypted;
}

/**
 * Gets or creates an encryption key for a voter
 * @param {string} voterId - The voter's EPIC number
 * @returns {Promise<Buffer>} - The voter's decrypted AES key
 */
export async function getOrCreateVoterKey(voterId) {
  try {
    // Try to find existing key
    const keyRecord = await prisma.encryptionKey.findUnique({
      where: { voter_id: voterId },
    });

    if (keyRecord) {
      // Decrypt the stored key
      return decryptVoterKeyWithMaster(keyRecord.encrypted_key);
    }

    // Create new key
    const rawKey = generateVoterKey(voterId);
    const encryptedKey = encryptVoterKeyWithMaster(rawKey);

    // Store encrypted key in database
    await prisma.encryptionKey.create({
      data: {
        voter_id: voterId,
        encrypted_key: encryptedKey,
      },
    });

    return rawKey;
  } catch (error) {
    console.error("Error getting/creating voter key:", error);
    throw error;
  }
}

/**
 * Encrypts a payload using the voter's key
 * @param {string} voterId - The voter's EPIC number
 * @param {object} payload - The data to encrypt
 * @returns {Promise<{encrypted: string, iv: string}>} - Encrypted data and IV
 */
export async function encryptPayload(voterId, payload) {
  if (!voterId || typeof voterId !== "string") {
    throw new Error("voterId is required and must be a string");
  }
  if (!payload || typeof payload !== "object") {
    throw new Error("payload is required and must be an object");
  }

  try {
    // Get or create voter's key
    const voterKey = await getOrCreateVoterKey(voterId);

    // Generate random IV for this encryption
    const iv = crypto.randomBytes(16);

    // Encrypt using AES-256-GCM
    const cipher = crypto.createCipheriv("aes-256-gcm", voterKey, iv);

    const plaintext = JSON.stringify(payload);
    let encrypted = cipher.update(plaintext, "utf8", "hex");
    encrypted += cipher.final("hex");

    // Get authentication tag
    const authTag = cipher.getAuthTag().toString("hex");

    // Return encrypted data with IV and authTag
    return {
      encrypted: `${encrypted}:${authTag}`, // Combine encrypted data and auth tag
      iv: iv.toString("hex"),
    };
  } catch (error) {
    console.error("Error encrypting payload:", error);
    throw error;
  }
}

/**
 * Decrypts a payload using the voter's key
 * @param {string} voterId - The voter's EPIC number
 * @param {string} encryptedData - Encrypted data with auth tag
 * @param {string} ivHex - Initialization vector (hex string)
 * @returns {Promise<object>} - Decrypted payload
 */
export async function decryptPayload(voterId, encryptedData, ivHex) {
  try {
    // Get voter's key
    const keyRecord = await prisma.encryptionKey.findUnique({
      where: { voter_id: voterId },
    });

    if (!keyRecord) {
      throw new Error(
        `Encryption key not found for voter: ${voterId}. Data may have been shredded.`
      );
    }

    // Decrypt the voter key
    const voterKey = decryptVoterKeyWithMaster(keyRecord.encrypted_key);

    // Split encrypted data and auth tag
    const [encrypted, authTag] = encryptedData.split(":");

    if (!encrypted || !authTag) {
      throw new Error("Invalid encrypted data format: missing auth tag");
    }
    const iv = Buffer.from(ivHex, "hex");

    // Decrypt
    const decipher = crypto.createDecipheriv("aes-256-gcm", voterKey, iv);
    decipher.setAuthTag(Buffer.from(authTag, "hex"));

    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");

    return JSON.parse(decrypted);
  } catch (error) {
    console.error("Error decrypting payload:", error);
    throw error;
  }
}

/**
 * Deletes a voter's encryption key (Cryptographic Shredding)
 * @param {string} voterId - The voter's EPIC number
 * @returns {Promise<void>}
 */
export async function deleteVoterKey(voterId) {
  try {
    // Delete the encryption key
    await prisma.encryptionKey.delete({
      where: { voter_id: voterId },
    });

    console.log(
      `âœ… Encryption key deleted for voter: ${voterId}. Data is now cryptographically shredded.`
    );
  } catch (error) {
    if (error.code === "P2025") {
      // Key already deleted
      console.log(`Key already deleted for voter: ${voterId}`);
      return;
    }
    console.error("Error deleting voter key:", error);
    throw error;
  }
}

/**
 * Checks if a voter's data can be decrypted (key exists)
 * @param {string} voterId - The voter's EPIC number
 * @returns {Promise<boolean>} - True if key exists, false if shredded
 */
export async function canDecryptVoterData(voterId) {
  try {
    const keyRecord = await prisma.encryptionKey.findUnique({
      where: { voter_id: voterId },
    });
    return !!keyRecord;
  } catch (error) {
    return false;
  }
}





















File: /src/lib/hashVerification.js

import crypto from 'crypto';
import { prisma } from './db';

/**
 * Verifies the integrity of the hash chain using encrypted payloads
 * This ensures the chain is valid without needing to decrypt the data
 * 
 * @param {string} userId - Optional: Verify chain for specific user
 * @returns {Promise<{valid: boolean, errors: Array, verifiedCount: number}>}
 */
export async function verifyLedgerIntegrity(userId = null) {
  const errors = [];
  let verifiedCount = 0;
  let totalEntries = 0;

  try {
    // 1. Get distinct User IDs if we are checking everything
    let targetUserIds = [];
    if (userId) {
      targetUserIds = [userId];
    } else {
      const users = await prisma.user.findMany({ select: { id: true } });
      targetUserIds = users.map(u => u.id);
    }

    // 2. Iterate through EACH user separately (Per-Voter Chain)
    for (const uid of targetUserIds) {
      const ledgerEntries = await prisma.auditLog.findMany({
        where: { userId: uid },
        orderBy: { timestamp: 'asc' }, // Chronological order per user
      });

      if (ledgerEntries.length === 0) continue;

      totalEntries += ledgerEntries.length;
      let prevHash = "0"; // Reset Genesis hash for EVERY new user

      for (let i = 0; i < ledgerEntries.length; i++) {
        const entry = ledgerEntries[i];

        // A. Verify Chain Link
        if (entry.prev_hash !== prevHash) {
          errors.push({
            entryId: entry.id,
            userId: uid,
            issue: 'Broken chain link',
            expected: prevHash,
            actual: entry.prev_hash,
            message: `User ${uid} chain broken at entry ${entry.id}`
          });
          // If link is broken, we reset prevHash to current to try and verify the rest linearly
          // or we can stop verification for this user.
        }

        const signatureToUse = entry.signature || "SYSTEM_SIGNED";

        // B. Recalculate Hash
        const calculatedHash = crypto
          .createHash('sha256')
          .update(
            entry.prev_hash + 
            entry.encrypted_payload + 
            entry.iv + 
            signatureToUse 
          )
          .digest('hex');

        // C. Verify Data Integrity
        if (calculatedHash !== entry.curr_hash) {
          errors.push({
            entryId: entry.id,
            userId: uid,
            issue: 'Hash mismatch',
            expected: calculatedHash,
            actual: entry.curr_hash,
            message: `Data tampering detected in entry ${entry.id}`
          });
        } else {
          verifiedCount++;
        }

        // Set for next iteration
        prevHash = entry.curr_hash;
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      verifiedCount,
      totalEntries,
      message: errors.length === 0 
        ? `âœ… Integrated Verified: ${verifiedCount}/${totalEntries} entries clean.` 
        : `âŒ Integrity Failed: ${errors.length} errors found.`
    };

  } catch (error) {
    console.error('Verification Fatal Error:', error);
    return { valid: false, errors: [error.message] };
  }
}



/**
 * Verifies a specific ledger entry's hash
 * @param {string} entryId - The audit log entry ID
 * @returns {Promise<{valid: boolean, error?: string}>}
 */
export async function verifySingleEntry(entryId) {
  try {
    const entry = await prisma.auditLog.findUnique({
      where: { id: entryId },
      select: {
        id: true,
        userId: true,
        encrypted_payload: true,
        iv: true,
        signature: true,
        prev_hash: true,
        curr_hash: true,
      },
    });

    if (!entry) {
      return { valid: false, error: 'Entry not found' };
    }

    // Get previous entry to verify chain link
    const prevEntry = await prisma.auditLog.findFirst({
      where: {
        userId: entry.userId,
        curr_hash: entry.prev_hash,
      },
    });

    const prevHash = prevEntry?.curr_hash || "0";

    // Recalculate hash using ENCRYPTED payload
    const calculatedHash = crypto
      .createHash('sha256')
      .update(
        prevHash + 
        entry.encrypted_payload + // âœ… Encrypted payload
        entry.iv + 
        entry.signature
      )
      .digest('hex');

    const valid = calculatedHash === entry.curr_hash;
    
    return {
      valid,
      error: valid ? null : 'Hash mismatch - data may have been tampered with',
      calculatedHash,
      storedHash: entry.curr_hash,
    };
  } catch (error) {
    return { valid: false, error: error.message };
  }
}

/**
 * Verifies hash chain for a specific voter
 * @param {string} epicNumber - Voter's EPIC number
 * @returns {Promise<{valid: boolean, errors: Array, verifiedCount: number}>}
 */
export async function verifyVoterChain(epicNumber) {
  try {
    const user = await prisma.user.findUnique({
      where: { epic_number: epicNumber.toUpperCase() },
      select: { id: true },
    });

    if (!user) {
      return {
        valid: false,
        errors: [{ issue: 'User not found', message: `No user found with EPIC: ${epicNumber}` }],
        verifiedCount: 0,
      };
    }

    return await verifyLedgerIntegrity(user.id);
  } catch (error) {
    return {
      valid: false,
      errors: [{ issue: 'Verification failed', message: error.message }],
      verifiedCount: 0,
    };
  }
}





















File: /src/lib/pouchdb.js

let localDB = null;
let PouchDB = null;

const getDB = async () => {
  if (typeof window === "undefined") {
    return null;
  }

  // Dynamically import PouchDB only in browser
  if (!PouchDB) {
    PouchDB = (await import("pouchdb-browser")).default;
  }

  if (!localDB) {
    localDB = new PouchDB("vlink_local_voters");
  }
  return localDB;
};

export async function saveVoterLocally(voterData) {
  const db = await getDB();
  if (!db) return { success: false, error: "Database not available on server" };

  // Validate required fields
  if (!voterData.epic && !voterData.epic_number) {
    return { success: false, error: "EPIC number is required" };
  }

  const epic = (
    voterData.epic ||
    voterData.epic_number ||
    "UNKNOWN"
  ).toUpperCase();

  const enrollmentRecord = {
    _id: `enroll_${epic}_${new Date().getTime()}`,
    epic: epic,
    epic_number: epic, // Support both field names
    firstName: voterData.firstName || "",
    lastName: voterData.lastName || "",
    aadhaar: voterData.aadhaar || voterData.aadhaar_uid || "",
    aadhaar_uid: voterData.aadhaar || voterData.aadhaar_uid || "",
    constituency: voterData.constituency || "",
    status: "OFFLINE_PENDING",
    version: 2.1,
    timestamp: new Date().toISOString(),
    // Network quality metadata (optional)
    savedReason: voterData.savedReason || "OFFLINE", // "OFFLINE" | "HIGH_LATENCY"
    savedLatency: voterData.savedLatency || null, // Latency in ms when saved
    lastSyncLatency: null, // Will be set when synced
    lastSyncQuality: null, // "good" | "poor" - will be set when synced
  };

  try {
    const response = await db.put(enrollmentRecord);
    return { success: true, id: response.id };
  } catch (err) {
    console.error("Local Buffer Write Error:", err);
    return { success: false, error: err.message };
  }
}

export async function getLocalEnrollments() {
  const db = await getDB();
  if (!db) return [];

  try {
    const result = await db.allDocs({ include_docs: true });
    return result.rows
      .map((row) => row.doc)
      .filter((doc) => doc.status === "OFFLINE_PENDING");
  } catch (err) {
    console.error("Fetch Local Docs Error:", err);
    return [];
  }
}

/**
 * Marks a document as synced in PouchDB
 * @param {string} docId - Document ID to mark as synced
 * @param {number} [syncLatency] - Optional latency at time of sync
 * @param {string} [syncQuality] - Optional quality indicator ("good" | "poor")
 */
export async function markAsSynced(docId, syncLatency = null, syncQuality = null) {
  const db = await getDB();
  if (!db) return { success: false, error: "Database not available" };

  try {
    const doc = await db.get(docId);
    doc.status = "SYNCED";
    doc.synced_at = new Date().toISOString();
    // Record sync network quality metadata
    if (syncLatency !== null) doc.lastSyncLatency = syncLatency;
    if (syncQuality !== null) doc.lastSyncQuality = syncQuality;
    await db.put(doc);
    return { success: true };
  } catch (err) {
    console.error("Mark as synced error:", err);
    return { success: false, error: err.message };
  }
}

/**
 * Removes synced documents from PouchDB (cleanup)
 */
export async function removeSyncedDocuments() {
  const db = await getDB();
  if (!db) return { success: false, error: "Database not available" };

  try {
    const result = await db.allDocs({ include_docs: true });
    const syncedDocs = result.rows
      .map((row) => row.doc)
      .filter((doc) => doc.status === "SYNCED");

    if (syncedDocs.length === 0) {
      return { success: true, removed: 0 };
    }

    await Promise.all(syncedDocs.map((doc) => db.remove(doc._id, doc._rev)));

    return { success: true, removed: syncedDocs.length };
  } catch (err) {
    console.error("Remove synced documents error:", err);
    return { success: false, error: err.message };
  }
}


export async function clearLocalDB() {
  const db = await getDB();
  if (!db) return;

  try {
    const docs = await db.allDocs();
    await Promise.all(docs.rows.map((row) => db.remove(row.id, row.value.rev)));
    return { success: true };
  } catch (err) {
    console.error("Clear DB Error:", err);
    return { success: false, error: err.message };
  }
}

export async function getOfflineData() {
  try {
    const result = await db.allDocs({ include_docs: true });
    // Filter out internal design docs if any, return just the data
    return result.rows.map((row) => row.doc);
  } catch (error) {
    console.error("Failed to fetch local buffer:", error);
    return [];
  }
}

export async function clearOfflineData() {
  try {
    // Destroying recreates the DB on next call, effectively wiping it
    await db.destroy();
    db = new PouchDB("voter_offline_buffer");
    return { success: true };
  } catch (error) {
    console.error("Failed to clear local buffer:", error);
    return { success: false };
  }
}





















File: /src/lib/rabbitmq.js

import amqp from "amqplib";

const RABBITMQ_URL = process.env.RABBITMQ_URL || "amqp://localhost";

// 1. CHANGE TO v5
const QUEUE_NAME = "relocation_ledger_queue_v7";
const DLQ_NAME = "relocation_ledger_queue_dlq";

export async function sendToRelocationQueue(payload) {
  let connection = null;
  let channel = null;

  try {
    connection = await amqp.connect(RABBITMQ_URL);
    channel = await connection.createChannel();

    // 2. CRITICAL FIX: Added 'arguments' to match the Worker
    await channel.assertQueue(QUEUE_NAME, {
      durable: true,
      arguments: {
        "x-dead-letter-exchange": "",
        "x-dead-letter-routing-key": DLQ_NAME,
      },
    });

    const sent = channel.sendToQueue(
      QUEUE_NAME,
      Buffer.from(JSON.stringify(payload)),
      { persistent: true }
    );

    if (sent) {
      console.log(" [x] Sent Packet to Queue:", payload.requestId || "N/A");
    } else {
      console.warn(" [!] Queue buffer full.");
    }

    await channel.close();
    await connection.close();

    return { success: true };
  } catch (error) {
    console.error("RabbitMQ Error:", error);
    try {
      if (channel) await channel.close();
      if (connection) await connection.close();
    } catch (ignore) {}

    return { success: false, error: "Messaging Broker Offline" };
  }
}





















File: /src/lib/validation.js

/**
 * Frontend Validation Utilities
 * Provides type checking and validation for login credentials
 */

/**
 * Validates EPIC Number format
 * EPIC format: 5 letters followed by 7 digits (e.g., VLINK1234567)
 */
export function validateEPIC(epic) {
  if (!epic || typeof epic !== "string") {
    return {
      isValid: false,
      error: "EPIC number is required",
    };
  }

  const trimmed = epic.trim().toUpperCase();
  
  // Remove spaces and hyphens
  const cleaned = trimmed.replace(/[\s-]/g, "");

  // Check length (should be 10 characters: 3 letters + 7 digits)
  if (cleaned.length !== 12) {
    return {
      isValid: false,
      error: "EPIC number must be exactly 12 characters (e.g., VLINK1234567)",
    };
  }

  // Check format: 3 letters followed by 7 digits
  const epicPattern = /^[A-Z]{5}[0-9]{7}$/;
  if (!epicPattern.test(cleaned)) {
    return {
      isValid: false,
      error: "EPIC number must be 5 letters followed by 7 digits (e.g., VLINK1234567)",
    };
  }

  return {
    isValid: true,
    normalized: cleaned,
    error: null,
  };
}

/**
 * Validates Government ID format
 * Gov ID format: Can be alphanumeric, may include hyphens (e.g., GOV-XXXX-XXXX or GOV123456)
 */
export function validateGovID(govId) {
  if (!govId || typeof govId !== "string") {
    return {
      isValid: false,
      error: "Government ID is required",
    };
  }

  const trimmed = govId.trim().toUpperCase();
  
  // Remove spaces but keep hyphens
  const cleaned = trimmed.replace(/\s/g, "");

  // Check minimum length
  if (cleaned.length < 6) {
    return {
      isValid: false,
      error: "Government ID must be at least 6 characters",
    };
  }

  // Check maximum length
  if (cleaned.length > 20) {
    return {
      isValid: false,
      error: "Government ID must not exceed 20 characters",
    };
  }

  // Allow alphanumeric and hyphens
  const govIdPattern = /^[A-Z0-9-]+$/;
  if (!govIdPattern.test(cleaned)) {
    return {
      isValid: false,
      error: "Government ID can only contain letters, numbers, and hyphens",
    };
  }

  return {
    isValid: true,
    normalized: cleaned,
    error: null,
  };
}

/**
 * Validates password strength
 */
export function validatePassword(password, isClaim = false) {
  if (!password || typeof password !== "string") {
    return {
      isValid: false,
      error: "Password is required",
    };
  }

  const trimmed = password.trim();

  // Minimum length check
  if (trimmed.length < 8) {
    return {
      isValid: false,
      error: "Password must be at least 8 characters long",
    };
  }

  // Maximum length check
  if (trimmed.length > 128) {
    return {
      isValid: false,
      error: "Password must not exceed 128 characters",
    };
  }

  // For new password (claim), check strength requirements
  if (isClaim) {
    // Check for at least one uppercase letter
    if (!/[A-Z]/.test(trimmed)) {
      return {
        isValid: false,
        error: "Password must contain at least one uppercase letter",
      };
    }

    // Check for at least one lowercase letter
    if (!/[a-z]/.test(trimmed)) {
      return {
        isValid: false,
        error: "Password must contain at least one lowercase letter",
      };
    }

    // Check for at least one number
    if (!/[0-9]/.test(trimmed)) {
      return {
        isValid: false,
        error: "Password must contain at least one number",
      };
    }

    // Check for at least one special character
    if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(trimmed)) {
      return {
        isValid: false,
        error: "Password must contain at least one special character",
      };
    }
  }

  return {
    isValid: true,
    normalized: trimmed,
    error: null,
  };
}

/**
 * Validates all login credentials before submission
 */
export function validateLoginCredentials(identifier, password, type = "voter") {
  const errors = {};

  // Validate identifier based on type
  if (type === "voter") {
    const epicValidation = validateEPIC(identifier);
    if (!epicValidation.isValid) {
      errors.identifier = epicValidation.error;
    }
  } else if (type === "admin" || type === "officer") {
    const govIdValidation = validateGovID(identifier);
    if (!govIdValidation.isValid) {
      errors.identifier = govIdValidation.error;
    }
  }

  // Validate password
  const passwordValidation = validatePassword(password, false);
  if (!passwordValidation.isValid) {
    errors.password = passwordValidation.error;
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  };
}

/**
 * Validates claim/register credentials
 */
export function validateClaimCredentials(epic, password) {
  const errors = {};

  // Validate EPIC
  const epicValidation = validateEPIC(epic);
  if (!epicValidation.isValid) {
    errors.identifier = epicValidation.error;
  }

  // Validate password with strength requirements
  const passwordValidation = validatePassword(password, true);
  if (!passwordValidation.isValid) {
    errors.password = passwordValidation.error;
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  };
}

/**
 * Type casting utilities
 */
export function castToEPIC(value) {
  if (!value || typeof value !== "string") return "";
  return value.trim().toUpperCase().replace(/[\s-]/g, "");
}

export function castToGovID(value) {
  if (!value || typeof value !== "string") return "";
  return value.trim().toUpperCase().replace(/\s/g, "");
}

export function sanitizePassword(value) {
  if (!value || typeof value !== "string") return "";
  return value.trim();
}

/**
 * Validates Aadhaar Number format
 * Aadhaar format: 12 digits (e.g., 1234 5678 9012)
 */
export function validateAadhaar(aadhaar) {
  if (!aadhaar || typeof aadhaar !== "string") {
    return {
      isValid: false,
      error: "Aadhaar number is required",
    };
  }

  // Remove spaces and hyphens
  const cleaned = aadhaar.trim().replace(/[\s-]/g, "");

  // Check if it's all digits
  if (!/^\d+$/.test(cleaned)) {
    return {
      isValid: false,
      error: "Aadhaar number must contain only digits",
    };
  }

  // Check length (should be 12 digits)
  if (cleaned.length !== 12) {
    return {
      isValid: false,
      error: "Aadhaar number must be exactly 12 digits",
    };
  }

  return {
    isValid: true,
    normalized: cleaned,
    error: null,
  };
}

/**
 * Validates Name (First/Last Name)
 */
export function validateName(name, fieldName = "Name") {
  if (!name || typeof name !== "string") {
    return {
      isValid: false,
      error: `${fieldName} is required`,
    };
  }

  const trimmed = name.trim();

  // Check minimum length
  if (trimmed.length < 2) {
    return {
      isValid: false,
      error: `${fieldName} must be at least 2 characters long`,
    };
  }

  // Check maximum length
  if (trimmed.length > 50) {
    return {
      isValid: false,
      error: `${fieldName} must not exceed 50 characters`,
    };
  }

  // Check for valid characters (letters, spaces, hyphens, apostrophes)
  const namePattern = /^[a-zA-Z\s'-]+$/;
  if (!namePattern.test(trimmed)) {
    return {
      isValid: false,
      error: `${fieldName} can only contain letters, spaces, hyphens, and apostrophes`,
    };
  }

  return {
    isValid: true,
    normalized: trimmed,
    error: null,
  };
}

/**
 * Type casting for Aadhaar
 */
export function castToAadhaar(value) {
  if (!value || typeof value !== "string") return "";
  // Remove all non-digits
  return value.replace(/\D/g, "").slice(0, 12);
}

/**
 * Type casting for Name
 */
export function castToName(value) {
  if (!value || typeof value !== "string") return "";
  return value.trim();
}





















File: /src/lib/zones.js

/**
 * Consistent Zones/Constituencies List
 * This ensures all zones are consistent across the application
 * and maintains backward compatibility with existing data
 */

// Standard zone format: "Zone X - Location Name"
export const ZONES = [
  "Zone A - North Delhi",
  "Zone B - South Delhi",
  "Zone C - East Delhi",
  "Zone D - West Delhi",
  "Zone E - Central Delhi",
];

// Legacy zone formats (for backward compatibility)
export const LEGACY_ZONES = [
  "ZONE A - NORTH DELHI",
  "ZONE B - SOUTH DELHI",
  "ZONE C - EAST DELHI",
  "ZONE D - WEST DELHI",
  "ZONE E - CENTRAL DELHI",
];

/**
 * Normalizes zone name to standard format
 * Handles both legacy and new formats
 */
export function normalizeZone(zone) {
  if (!zone || typeof zone !== "string") return null;
  
  const trimmed = zone.trim();
  
  // Check if it's already in standard format
  if (ZONES.includes(trimmed)) {
    return trimmed;
  }
  
  // Check if it's in legacy format and convert
  const upperTrimmed = trimmed.toUpperCase();
  const legacyIndex = LEGACY_ZONES.findIndex(
    (legacy) => legacy.toUpperCase() === upperTrimmed
  );
  
  if (legacyIndex !== -1) {
    return ZONES[legacyIndex];
  }
  
  // Try to match by pattern (Zone X - Location)
  const pattern = /^(ZONE|Zone)\s+([A-E])\s*-\s*(.+)$/i;
  const match = trimmed.match(pattern);
  
  if (match) {
    const zoneLetter = match[2].toUpperCase();
    const location = match[3]
      .split(/\s+/)
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(" ");
    
    return `Zone ${zoneLetter} - ${location}`;
  }
  
  // Return as-is if no match (preserve existing data)
  return trimmed;
}

/**
 * Validates if a zone is valid
 */
export function isValidZone(zone) {
  if (!zone || typeof zone !== "string") return false;
  const normalized = normalizeZone(zone);
  return ZONES.includes(normalized) || LEGACY_ZONES.includes(zone.toUpperCase());
}





















File: /src/workers/ledgerWorker.js



import "dotenv/config";
import amqp from "amqplib";
import { PrismaClient } from "@prisma/client";
import crypto from "crypto";
import { encryptPayload } from "../lib/encryption.js";

const prisma = new PrismaClient();
const RABBITMQ_URL = process.env.RABBITMQ_URL;

// using v7 to match currently working queue
const QUEUE_NAME = "relocation_ledger_queue_v7";
const DLQ_NAME = "relocation_ledger_queue_dlq";

const DEFAULT_SIG = "SYSTEM_SIGNED"; 

let connection;
let channel;


async function connectRabbitMQ() {
  while (true) {
    try {
      connection = await amqp.connect(RABBITMQ_URL);
      connection.on("close", () => {
        console.error("âŒ RabbitMQ connection closed. Reconnecting...");
        process.exit(1);
      });
      connection.on("error", () => {});
      return connection;
    } catch (err) {
      console.error("RabbitMQ connect failed. Retrying in 5s...");
      await new Promise((r) => setTimeout(r, 5000));
    }
  }
}


async function startWorker() {
  if (!RABBITMQ_URL) {
    console.error("âŒ Error: RABBITMQ_URL is missing from .env");
    process.exit(1);
  }

  try {
    const connection = await connectRabbitMQ();
    channel = await connection.createChannel();

    // Ensure Queue settings match Sender EXACTLY
    await channel.assertQueue(QUEUE_NAME, {
      durable: true,
      arguments: {
        "x-dead-letter-exchange": "",
        "x-dead-letter-routing-key": DLQ_NAME,
      },
    });

    await channel.assertQueue(DLQ_NAME, { durable: true });
    channel.prefetch(10);

    console.log(
      ` [*] Worker Connected to ${QUEUE_NAME} (High-Latency Mode Active)`
    );

    channel.consume(QUEUE_NAME, async (msg) => {
      if (!msg) return;

      let event;
      try {
        event = JSON.parse(msg.content.toString());
      } catch (e) {
        console.error("Malformed JSON, sending to DLQ");
        channel.nack(msg, false, false);
        return;
      }

      console.log(`ðŸ“¥ Processing: ${event.payload?.epic}`);

      try {
        // --- THE FIX IS HERE ---
        // We add the configuration object as the second argument
        await prisma.$transaction(
          async (tx) => {
            // 1. Snapshot
            const existingUser = await tx.user.findUnique({
              where: { epic_number: event.payload.epic.toUpperCase() },
              include: {
                auditLogs: { orderBy: { timestamp: "desc" }, take: 1 },
              },
            });

            // 2. Logic / Version Checks and Conflict Handling
            if (existingUser && event.expected_version !== undefined) {
              if (existingUser.version !== event.expected_version) {
                try {
                  await tx.conflictLog.create({
                    data: {
                      epic_number: event.payload?.epic || "UNKNOWN",
                      original_payload: event,
                      conflict_reason: "VERSION_MISMATCH",
                      status: "PENDING",
                      expected_version: event.expected_version,
                      actual_version: existingUser.version,
                    },
                  });

                  throw new Error("VERSION_MISMATCH_HANDLED");

                } catch (dbError) {
                  console.error("ðŸ”¥ DB Write Failed. Sending to DLQ.");
                  throw new Error("DLQ_REQUIRED");
                }
              }
            }

            // 3. Crypto (Can be slow)
            const { encrypted, iv } = await encryptPayload(
              event.payload.epic,
              event.payload
            );

            const finalSignature = event.signature || DEFAULT_SIG;
            const prevHash = existingUser?.auditLogs[0]?.curr_hash || "0";

            const currHash = crypto
              .createHash("sha256")
              .update(prevHash + encrypted + iv + finalSignature)
              .digest("hex");

            // 4. Update User (The part that was failing)
            const updatedUser = await tx.user.upsert({
              where: { epic_number: event.payload.epic.toUpperCase() },
              update: {
                firstName: event.payload.firstName,
                lastName: event.payload.lastName,
                constituency: event.payload.constituency,
                aadhaar_uid: event.payload.aadhaar,
                version: { increment: 1 },
                status: "ACTIVE",
              },
              create: {
                epic_number: event.payload.epic.toUpperCase(),
                firstName: event.payload.firstName,
                lastName: event.payload.lastName,
                aadhaar_uid: event.payload.aadhaar,
                constituency: event.payload.constituency,
                version: 1,
                status: "ACTIVE",
                password_hash: "PENDING_CLAIM",
              },
            });

            // 5. Audit Log
            await tx.auditLog.create({
              data: {
                userId: updatedUser.id,
                eventType: event.type,
                encrypted_payload: encrypted,
                iv: iv,
                signature: finalSignature,
                prev_hash: prevHash,
                curr_hash: currHash,
              },
            });
            // 6. Relocation Request Approval
            if (event.requestId) {
              await tx.relocationRequest.update({
                where: { id: event.requestId },
                data: { status: "APPROVED" },
              });
              console.log(`ðŸ“ Request ${event.requestId} marked APPROVED`);
            }
          },
          {
            // --- EXTENDED TIMEOUTS ---
            maxWait: 5000, // Wait 5s for connection
            timeout: 20000, // Allow 20s for logic execution
          }
        );

        console.log(`âœ… Success: ${event.payload?.epic}`);
        channel.ack(msg);
      } catch (processError) {
        console.error(`âŒ Failed: ${processError.message}`);

        if (processError.message === "VERSION_MISMATCH_HANDLED") {
          channel.ack(msg);
          return;
        }

        if (processError.message === "DLQ_REQUIRED") {
          channel.nack(msg, false, false);
          return;
        }

        // Error Handling / DLQ Logic
        try {
          await prisma.conflictLog.create({
            data: {
              epic_number: event.payload?.epic || "UNKNOWN",
              original_payload: event,
              conflict_reason: "PROCESSING_ERROR",
              status: "PENDING",
              error_message: processError.message,
            },
          });
          channel.ack(msg);
        } catch (dbError) {
          console.error("ðŸ”¥ DB Write Failed. Sending to DLQ.");
          channel.nack(msg, false, false);
        }
      }
    });
  } catch (err) {
    console.error("Worker Error:", err);
    process.exit(1);
  }
}

startWorker();

process.on("SIGTERM", async () => {
  console.log("ðŸ›‘ Shutting down worker...");
  await prisma.$disconnect();
  if (channel) await channel.close();
  if (connection) await connection.close();
  process.exit(0);
});





















